# -*- coding: utf-8 -*-
#!/usr/bin/python2.7

"""
 Projekt, IB910C - S
 Johan Beck-Nor√©n, jobe4452
 Ubuntu 12.10
 Python 2.7
"""

import os, sys
from time import sleep
import pygame
from pygame.locals import *
#import Box2D
from Box2D.b2 import *
from Box2D import *
#from menu_key import *
from menu import *

if not pygame.font: print "Warning, fonts disabled."
if not pygame.mixer: print "Warning, sound disabled."

# --- constants ---
# Box2D deals with meters, but we want to display pixels, 
# so define a conversion factor:
PPM=20.0 # pixels per meter
TARGET_FPS=60
TIME_STEP=1.0/TARGET_FPS
SCREEN_WIDTH, SCREEN_HEIGHT=640,480
vel_iters, pos_iters = 10, 10

# --- pygame setup ---
pygame.init()
screen=pygame.display.set_mode((SCREEN_WIDTH,SCREEN_HEIGHT), 0, 32)
pygame.display.set_caption('Ball-in-box')
background=pygame.Surface(screen.get_size())
background=background.convert()
background.fill((255,255,255))
clock=pygame.time.Clock()

# --- pybox2d world setup ---
# Create the world
world=world(gravity=(0,-9.82),doSleep=True)

# --- Game variables ---
*introMenu = Menu()
introFrames = 2*TARGET_FPS # Show intro for 2 seconds
pauseSimulation = 0 # Boolean to pause Box2d physics simulation

colors = {
    staticBody  : (255,255,255,255),
    dynamicBody : (127,127,127,255),
}

staticBodies = []
dynamicBodies = []

running=True	# Main game loop

def addStaticBodyToContainer(staticBody):
	global staticBodies
	staticBodies.append(staticBody)
	
def addDynamicBodyToContainer(dynamicBody):
	global dynamicBodies
	dynamicBodies.append(dynamicBody)
	
def toRad(degree):
	return degree*(3.1415/180.0)
	
def checkContacts():
	global world
	
	# Check of ball in goal
	for contact in world.contacts:
		fixA = contact.fixtureA
		fixB = contact.fixtureB
		if fixA.body.userData=='ball' or fixB.body.userData=='ball':
			if fixA.body.userData=='goal' or fixB.body.userData=='goal':
				return True

def runIntro():
	global SCREEN_WIDTH, SCREEN_HEIGHT
#	print '('+str(SCREEN_WIDTH)+', '+str(SCREEN_HEIGHT)+')'
#	background=pygame.Surface((SCREEN_WIDTH,SCREEN_HEIGHT))
#	background=background.convert()
	if pygame.font:
		font=pygame.font.Font(None, 48)
		text=font.render("Ball-in-box",1,(255,255,255,255))
		textpos=text.get_rect(centerx=SCREEN_WIDTH/2, centery=SCREEN_HEIGHT/2)
		
		introFrameCounter=0
		screen.blit(text, textpos)
		while introFrameCounter<=120:
			pygame.display.flip()
			introFrameCounter=introFrameCounter+1
#		sleep(1.5)
	else:
		print 'NO FONT FOR YOU!'
	print 'Intro'
#	screen.fill((0,0,0,0))

def event_handler():
	global running,pauseSimulation
	for event in pygame.event.get():
		if event.type==QUIT or (event.type==KEYUP and event.key==K_ESCAPE):
			# User closed the window or pressed escape
			running=False
		if event.type==KEYDOWN and event.key==K_o:
			# Pause/unpause simulation
			if pauseSimulation == 1:
				pauseSimulation = 0
			else:
				pauseSimulation = 1

def createLevelBodies():
	# Add file input for body creation here
	
	global world
	
	# Static body to hold the ground shape
	ground_body=world.CreateStaticBody(
		position=(0,1),
		shapes=polygonShape(box=(50,1)),
		density=0.0,
		)
	
	# Level obstacle static body
	static_block1=world.CreateStaticBody(
		position=(8,5),
		angle=-10*(3.1415/180),
		shapes=polygonShape(box=(4,1)),
		density = 0.0,
		)
	
	# Level goal static body
	static_goal=world.CreateStaticBody(
		position=(18,4),
		angle=0,
		shapes=polygonShape(box=(1,1.5)),
		density=0.0,
		userData='goal',
		)

	# Level ball dynamic body
	dynamic_body=world.CreateDynamicBody(
		position=(10,15),
		angle=15,
		angularDamping=2,
		userData="ball",
		shapes=circleShape(radius=1))

	# And add a box fixture onto it (with a nonzero density, so it will move)
	#box=dynamic_body.CreatePolygonFixture(box=(2,1), density=3, friction=0.3, restitution=0.3)
	circle=dynamic_body.CreateCircleFixture(
		radius=1.0, 
		friction=0.1,
		density=3.0, 
		restitution=0.3)

def main():
	global world # Box2D world object
	global staticBodies # Container for all static bodies in world
	global dynamicBodies # Container for all dynamic bodies in world
	global TIME_STEP
	global PPM
	global running
	global background
	global introFrames
	global pauseSimulation	# Boolean for pausing box2d simulation	
	
	flipswitch=1	# To stop printing "Gooooll"
	introCounter=0	# Counter for displaying intro

	
	createLevelBodies()
	
	# Store bodies in separate containers for static/dynamic
	for body in world.bodies:
		if body.type==staticBody:
			addStaticBodyToContainer(body)
		elif body.type==dynamicBody:
			addDynamicBodyToContainer(body)
	screen.fill((0,0,0,0))
	runIntro()

	# Main game loop
	while running:
		#Check the event queue
		event_handler()
		"""
		for event in pygame.event.get():
			if event.type==QUIT or (event.type==KEYUP and event.key==K_ESCAPE):
				# User closed the window or pressed escape
				running=False
			if event.type==KEYDOWN and event.key==K_o:
					if pauseSimulation == 1:
						pauseSimulation = 0
					else:
						pauseSimulation = 1
		"""

		# Check ball-goal collision/contact
		if checkContacts() and flipswitch==1:
			print 'Gooooll!'
			flipswitch=0
		
		# --- Draw the world ---
		
		# Clear screen
		screen.fill((0,0,0,0))
		
		# Draw intro text
		"""
		if introCounter <= introFrames:
			runIntro()
			introCounter = introCounter+1
		"""	
			
		for body in (world.bodies): # all bodies in world
			# The body gives us the position and angle of its shapes
			for fixture in body.fixtures:
				# The fixture hold information like density and friction,
				# and also the shape.
				shape=fixture.shape
				
				# Draw the circular ball shape
#				"""
				if body.userData=='ball':
					pygame.draw.circle(
						screen, (255,0,0,255),
						(int(body.position.x*PPM), 
						SCREEN_HEIGHT-int(body.position.y*PPM)),
						int(1*PPM),
						0)
				else:
					# Naively assume that this is a polygon shape. (not good normally!)
				    # We take the body's transform and multiply it with each 
				    # vertex, and then convert from meters to pixels with the scale
				    # factor.
				    vertices=[(body.transform*v)*PPM for v in shape.vertices]
				    
				    # But wait! It's upside-down! Pygame and Box2D orient their
				    # axes in different ways. Box2D is just like how you learned
				    # in high school, with positive x and y directions going
				    # right and up. Pygame, on the other hand, increases in the
				    # right and downward directions. This means we must flip
				    # the y components.
				    vertices=[(v[0], SCREEN_HEIGHT-v[1]) for v in vertices]
				    
				    if body.userData=='goal':
				    	pygame.draw.polygon(screen, (0,255,0,255), vertices, 1)
				    else:
				    	pygame.draw.polygon(screen, colors[body.type], vertices, 1)
#				"""
		if pauseSimulation==0:
			world.Step(TIME_STEP, 10, 10)
			
		clock.tick(TARGET_FPS)
		pygame.display.flip()
	pygame.quit()
	print('Done!')
main()
